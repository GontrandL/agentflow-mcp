"""
Modular Task Decomposition Patterns for SmartOrchestrator

This module provides reusable pattern-based decomposition strategies that analyze
tasks and break them down into optimal subtasks based on specific characteristics.

Architecture:
    DecompositionPattern (abstract base)
        ↓
    ConfigGenerationPattern, APIEndpointPattern, TestGenerationPattern
        ↓
    Analyze task characteristics → Generate optimal subtasks

Usage Example:
    >>> plan = Plan(complexity="high", decompose=True,
    ...             subtasks=[], requirements={})
    >>> pattern = ConfigGenerationPattern()
    >>> if pattern.matches(plan):
    ...     subtasks = pattern.decompose(plan)
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from dataclasses import dataclass


# Import Plan and Subtask from smart_orchestrator
try:
    from .smart_orchestrator import Plan, Subtask
except ImportError:
    # Fallback for testing or standalone use
    @dataclass
    class Subtask:
        """Individual subtask in decomposed plan"""
        id: str
        description: str
        dependencies: List[str]
        difficulty: str = "medium"
        error_risk: str = "medium"
        estimated_tokens: int = 1000

    @dataclass
    class Plan:
        """Execution plan generated by orchestrator"""
        complexity: str
        decompose: bool
        subtasks: List[Subtask]
        requirements: Dict[str, Any]


class DecompositionPattern(ABC):
    """
    Abstract base class for task decomposition patterns.

    DecompositionPattern provides a standard interface for analyzing tasks and
    breaking them down into manageable subtasks. Each concrete pattern implements
    specific logic for matching and decomposing different types of tasks.

    The pattern-based approach allows the SmartOrchestrator to:
    - Apply specialized decomposition strategies based on task characteristics
    - Reuse proven decomposition patterns across different tasks
    - Extend decomposition capabilities by adding new patterns
    - Maintain separation of concerns between orchestration and decomposition logic

    Subclasses must implement:
    - matches(plan): Determine if this pattern applies to the given plan
    - decompose(plan): Break down the plan into optimal subtasks

    Example:
        >>> class CustomPattern(DecompositionPattern):
        ...     def matches(self, plan: Plan) -> bool:
        ...         return "custom" in plan.requirements.get("type", "")
        ...
        ...     def decompose(self, plan: Plan) -> List[Subtask]:
        ...         return [Subtask(id="custom_1", description="...",
        ...                        dependencies=[], difficulty="medium",
        ...                        error_risk="low", estimated_tokens=500)]
    """

    @abstractmethod
    def matches(self, plan: Plan) -> bool:
        """
        Determine if this decomposition pattern matches the given plan.

        This method analyzes the plan's characteristics (complexity, requirements,
        existing subtasks) to decide whether this pattern is applicable.

        Args:
            plan: The execution plan to analyze

        Returns:
            True if this pattern should handle the plan's decomposition,
            False otherwise

        Example:
            >>> pattern = ConfigGenerationPattern()
            >>> plan = Plan(complexity="high", decompose=True, subtasks=[],
            ...            requirements={"type": "config"})
            >>> pattern.matches(plan)
            True
        """
        pass

    @abstractmethod
    def decompose(self, plan: Plan) -> List[Subtask]:
        """
        Decompose the given plan into a list of optimal subtasks.

        This method implements the pattern-specific logic for breaking down
        a task into manageable, independently executable subtasks. Each subtask
        should be clearly defined with appropriate difficulty, error risk, and
        token estimates.

        Args:
            plan: The execution plan to decompose

        Returns:
            List of Subtask objects representing the decomposed work

        Raises:
            ValueError: If the plan cannot be decomposed by this pattern

        Example:
            >>> pattern = APIEndpointPattern()
            >>> plan = Plan(complexity="high", decompose=True, subtasks=[],
            ...            requirements={"type": "api", "endpoints": 3})
            >>> subtasks = pattern.decompose(plan)
            >>> len(subtasks)
            5  # schema, routes, handlers, tests, docs
        """
        pass


class ConfigGenerationPattern(DecompositionPattern):
    """
    Decomposition pattern for YAML/JSON configuration generation tasks.

    This pattern specializes in breaking down configuration file generation into
    logical subtasks: schema validation, section generation, environment handling,
    validation, and documentation.

    Matches tasks that involve:
    - YAML or JSON configuration file generation
    - Environment-specific configurations
    - Configuration validation and schema design
    - Multi-section configuration structures

    Decomposition Strategy:
    1. Schema Design: Define configuration structure and validation rules
    2. Core Config: Generate main configuration sections
    3. Environment Configs: Create environment-specific overrides
    4. Validation: Implement configuration validation logic
    5. Documentation: Generate configuration documentation

    Example:
        >>> plan = Plan(
        ...     complexity="high",
        ...     decompose=True,
        ...     subtasks=[],
        ...     requirements={
        ...         "type": "config",
        ...         "format": "yaml",
        ...         "environments": ["dev", "staging", "prod"]
        ...     }
        ... )
        >>> pattern = ConfigGenerationPattern()
        >>> pattern.matches(plan)
        True
        >>> subtasks = pattern.decompose(plan)
        >>> [s.id for s in subtasks]
        ['config_schema', 'config_core', 'config_env', 'config_validation', 'config_docs']
    """

    def matches(self, plan: Plan) -> bool:
        """
        Check if plan involves configuration file generation.

        Returns True if:
        - Task type is "config", "configuration", or "yaml"
        - Requirements mention config-related keywords
        - Complexity is medium or high (simple configs don't need decomposition)
        """
        if not plan.decompose:
            return False

        req = plan.requirements
        task_type = req.get("type", "").lower()

        # Check for configuration-related keywords
        config_keywords = ["config", "configuration", "yaml", "json", "settings"]
        matches_type = any(keyword in task_type for keyword in config_keywords)

        # Check for complexity requirement
        needs_decomposition = plan.complexity in ["medium", "high"]

        return matches_type and needs_decomposition

    def decompose(self, plan: Plan) -> List[Subtask]:
        """
        Decompose configuration generation into specialized subtasks.

        Creates 5 subtasks covering the full configuration lifecycle:
        schema, core generation, environment variants, validation, and docs.
        """
        req = plan.requirements
        config_format = req.get("format", "yaml")
        environments = req.get("environments", ["dev", "prod"])

        subtasks = [
            Subtask(
                id="config_schema",
                description=f"Design configuration schema for {config_format} format. "
                           f"Define structure, required fields, types, and validation rules.",
                dependencies=[],
                difficulty="medium",
                error_risk="low",
                estimated_tokens=800
            ),
            Subtask(
                id="config_core",
                description=f"Generate core {config_format} configuration file with all "
                           f"base settings, defaults, and common sections.",
                dependencies=["config_schema"],
                difficulty="medium",
                error_risk="medium",
                estimated_tokens=1200
            ),
            Subtask(
                id="config_env",
                description=f"Create environment-specific configuration overrides for: "
                           f"{', '.join(environments)}. Handle environment variables and secrets.",
                dependencies=["config_core"],
                difficulty="medium",
                error_risk="medium",
                estimated_tokens=1000
            ),
            Subtask(
                id="config_validation",
                description=f"Implement configuration validation logic. Check schema compliance, "
                           f"required fields, value constraints, and cross-field dependencies.",
                dependencies=["config_schema"],
                difficulty="high",
                error_risk="high",
                estimated_tokens=1500
            ),
            Subtask(
                id="config_docs",
                description=f"Generate configuration documentation: field descriptions, "
                           f"examples, environment-specific notes, and usage guide.",
                dependencies=["config_core", "config_env"],
                difficulty="low",
                error_risk="low",
                estimated_tokens=800
            )
        ]

        return subtasks


class APIEndpointPattern(DecompositionPattern):
    """
    Decomposition pattern for REST API endpoint generation tasks.

    This pattern specializes in breaking down API development into structured
    subtasks: schema/models, routing, request handlers, middleware, tests, and docs.

    Matches tasks that involve:
    - REST API endpoint implementation
    - HTTP request/response handling
    - API route definition and organization
    - OpenAPI/Swagger documentation

    Decomposition Strategy:
    1. Schema/Models: Define request/response data models
    2. Routes: Define API routes and URL structure
    3. Handlers: Implement request handler functions
    4. Middleware: Add validation, auth, error handling
    5. Tests: Create endpoint integration tests
    6. API Docs: Generate OpenAPI/Swagger documentation

    Example:
        >>> plan = Plan(
        ...     complexity="high",
        ...     decompose=True,
        ...     subtasks=[],
        ...     requirements={
        ...         "type": "api",
        ...         "endpoints": ["GET /users", "POST /users", "PUT /users/:id"],
        ...         "framework": "express"
        ...     }
        ... )
        >>> pattern = APIEndpointPattern()
        >>> subtasks = pattern.decompose(plan)
        >>> [s.id for s in subtasks]
        ['api_schema', 'api_routes', 'api_handlers', 'api_middleware', 'api_tests', 'api_docs']
    """

    def matches(self, plan: Plan) -> bool:
        """
        Check if plan involves REST API endpoint generation.

        Returns True if:
        - Task type is "api", "endpoint", or "rest"
        - Requirements mention API-related keywords
        - Multiple endpoints are specified (needs decomposition)
        """
        if not plan.decompose:
            return False

        req = plan.requirements
        task_type = req.get("type", "").lower()

        # Check for API-related keywords
        api_keywords = ["api", "endpoint", "rest", "route", "http"]
        matches_type = any(keyword in task_type for keyword in api_keywords)

        # Check if multiple endpoints (worth decomposing)
        has_multiple_endpoints = len(req.get("endpoints", [])) > 1

        return matches_type and has_multiple_endpoints

    def decompose(self, plan: Plan) -> List[Subtask]:
        """
        Decompose API endpoint generation into specialized subtasks.

        Creates 6 subtasks covering the full API development lifecycle:
        models, routes, handlers, middleware, tests, and documentation.
        """
        req = plan.requirements
        endpoints = req.get("endpoints", [])
        framework = req.get("framework", "express")
        auth_required = req.get("auth_required", True)

        subtasks = [
            Subtask(
                id="api_schema",
                description=f"Define data models/schemas for API endpoints: {', '.join(endpoints)}. "
                           f"Include request validation schemas and response types.",
                dependencies=[],
                difficulty="medium",
                error_risk="medium",
                estimated_tokens=1000
            ),
            Subtask(
                id="api_routes",
                description=f"Define API routes for {framework}. Set up URL structure, "
                           f"HTTP methods, and route parameters for {len(endpoints)} endpoints.",
                dependencies=["api_schema"],
                difficulty="low",
                error_risk="low",
                estimated_tokens=600
            ),
            Subtask(
                id="api_handlers",
                description=f"Implement request handler functions for each endpoint. "
                           f"Handle request parsing, business logic, and response formatting.",
                dependencies=["api_schema", "api_routes"],
                difficulty="high",
                error_risk="high",
                estimated_tokens=2000
            ),
            Subtask(
                id="api_middleware",
                description=f"Implement middleware: request validation, "
                           f"{'authentication/authorization, ' if auth_required else ''}"
                           f"error handling, logging, and rate limiting.",
                dependencies=["api_routes"],
                difficulty="high",
                error_risk="high",
                estimated_tokens=1500
            ),
            Subtask(
                id="api_tests",
                description=f"Create integration tests for all {len(endpoints)} endpoints. "
                           f"Test success cases, error cases, validation, and edge cases.",
                dependencies=["api_handlers", "api_middleware"],
                difficulty="medium",
                error_risk="medium",
                estimated_tokens=1800
            ),
            Subtask(
                id="api_docs",
                description=f"Generate OpenAPI/Swagger documentation for all endpoints. "
                           f"Include request/response examples, error codes, and usage notes.",
                dependencies=["api_schema", "api_handlers"],
                difficulty="low",
                error_risk="low",
                estimated_tokens=700
            )
        ]

        return subtasks


class TestGenerationPattern(DecompositionPattern):
    """
    Decomposition pattern for unit and integration test generation tasks.

    This pattern specializes in breaking down test suite creation into structured
    subtasks: test planning, unit tests, integration tests, fixtures, and coverage.

    Matches tasks that involve:
    - Unit test generation
    - Integration test suites
    - Test fixture and mock creation
    - Test coverage analysis

    Decomposition Strategy:
    1. Test Planning: Analyze code and identify test cases
    2. Unit Tests: Create isolated unit tests for functions/classes
    3. Integration Tests: Create tests for component interactions
    4. Fixtures/Mocks: Set up test data and mock dependencies
    5. Coverage Analysis: Ensure comprehensive test coverage

    Example:
        >>> plan = Plan(
        ...     complexity="high",
        ...     decompose=True,
        ...     subtasks=[],
        ...     requirements={
        ...         "type": "test",
        ...         "test_types": ["unit", "integration"],
        ...         "framework": "jest",
        ...         "target_coverage": 90
        ...     }
        ... )
        >>> pattern = TestGenerationPattern()
        >>> subtasks = pattern.decompose(plan)
        >>> [s.id for s in subtasks]
        ['test_planning', 'test_unit', 'test_integration', 'test_fixtures', 'test_coverage']
    """

    def matches(self, plan: Plan) -> bool:
        """
        Check if plan involves test generation.

        Returns True if:
        - Task type is "test", "testing", or "spec"
        - Requirements mention test-related keywords
        - Multiple test types or high coverage target (needs decomposition)
        """
        if not plan.decompose:
            return False

        req = plan.requirements
        task_type = req.get("type", "").lower()

        # Check for test-related keywords
        test_keywords = ["test", "testing", "spec", "coverage", "unit", "integration"]
        matches_type = any(keyword in task_type for keyword in test_keywords)

        # Check if comprehensive testing is needed
        test_types = req.get("test_types", [])
        target_coverage = req.get("target_coverage", 0)
        needs_decomposition = len(test_types) > 1 or target_coverage >= 80

        return matches_type and needs_decomposition

    def decompose(self, plan: Plan) -> List[Subtask]:
        """
        Decompose test generation into specialized subtasks.

        Creates 5 subtasks covering the full testing lifecycle:
        planning, unit tests, integration tests, fixtures, and coverage.
        """
        req = plan.requirements
        test_types = req.get("test_types", ["unit", "integration"])
        framework = req.get("framework", "jest")
        target_coverage = req.get("target_coverage", 80)
        target_modules = req.get("modules", [])

        modules_desc = f" for modules: {', '.join(target_modules)}" if target_modules else ""

        subtasks = [
            Subtask(
                id="test_planning",
                description=f"Analyze code{modules_desc} and create test plan. "
                           f"Identify test cases, edge cases, and coverage goals ({target_coverage}%).",
                dependencies=[],
                difficulty="medium",
                error_risk="low",
                estimated_tokens=900
            ),
            Subtask(
                id="test_unit",
                description=f"Generate unit tests using {framework}. Create isolated tests for "
                           f"individual functions/classes{modules_desc}. Test success paths, "
                           f"error cases, and edge conditions.",
                dependencies=["test_planning"],
                difficulty="high",
                error_risk="medium",
                estimated_tokens=2000
            ),
            Subtask(
                id="test_integration",
                description=f"Generate integration tests using {framework}. Test component "
                           f"interactions, API calls, database operations, and end-to-end flows.",
                dependencies=["test_planning", "test_fixtures"],
                difficulty="high",
                error_risk="high",
                estimated_tokens=2200
            ),
            Subtask(
                id="test_fixtures",
                description=f"Create test fixtures and mocks. Set up test data, mock external "
                           f"dependencies, and configure test environment for {framework}.",
                dependencies=["test_planning"],
                difficulty="medium",
                error_risk="medium",
                estimated_tokens=1200
            ),
            Subtask(
                id="test_coverage",
                description=f"Analyze test coverage and fill gaps. Ensure {target_coverage}% "
                           f"coverage target is met. Add missing tests for uncovered code paths.",
                dependencies=["test_unit", "test_integration"],
                difficulty="medium",
                error_risk="low",
                estimated_tokens=1000
            )
        ]

        # Filter subtasks based on requested test types
        if "unit" not in test_types:
            subtasks = [s for s in subtasks if s.id != "test_unit"]
        if "integration" not in test_types:
            subtasks = [s for s in subtasks if s.id != "test_integration"]

        return subtasks


# Pattern registry for easy access
AVAILABLE_PATTERNS = {
    "config": ConfigGenerationPattern(),
    "api": APIEndpointPattern(),
    "test": TestGenerationPattern()
}


def get_matching_pattern(plan: Plan) -> Optional[DecompositionPattern]:
    """
    Find the first matching decomposition pattern for a given plan.

    This helper function iterates through all available patterns and returns
    the first one that matches the plan's characteristics.

    Args:
        plan: The execution plan to match

    Returns:
        Matching DecompositionPattern instance, or None if no match found

    Example:
        >>> plan = Plan(complexity="high", decompose=True, subtasks=[],
        ...            requirements={"type": "api", "endpoints": 3})
        >>> pattern = get_matching_pattern(plan)
        >>> pattern.__class__.__name__
        'APIEndpointPattern'
    """
    for pattern in AVAILABLE_PATTERNS.values():
        if pattern.matches(plan):
            return pattern
    return None


def decompose_with_pattern(plan: Plan) -> List[Subtask]:
    """
    Automatically decompose a plan using the appropriate pattern.

    This convenience function finds a matching pattern and applies it to
    decompose the plan. If no pattern matches, returns an empty list.

    Args:
        plan: The execution plan to decompose

    Returns:
        List of Subtask objects, or empty list if no pattern matches

    Example:
        >>> plan = Plan(complexity="high", decompose=True, subtasks=[],
        ...            requirements={"type": "config", "format": "yaml"})
        >>> subtasks = decompose_with_pattern(plan)
        >>> len(subtasks)
        5
    """
    pattern = get_matching_pattern(plan)
    if pattern:
        return pattern.decompose(plan)
    return []
