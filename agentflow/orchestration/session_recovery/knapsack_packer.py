"""
Knapsack Packer for SessionContextCurator

This module implements budget-guaranteed file packing using 0/1 Knapsack
greedy approximation. Ensures HARD guarantee: sum(sizes) <= budget_kb.

Replaces soft limits with mathematical guarantee (100% compliance).

Generated by: AgentFlow Worker 3 (DeepSeek V3)
Date: 2025-10-14
Cost: $0.10
Duration: 2 minutes
"""

from dataclasses import dataclass, field
from typing import List, Optional


@dataclass
class FileCandidate:
    """
    File candidate for packing.

    Attributes:
        path: File path
        relevance_score: Relevance to task (value)
        size_kb: Size in kilobytes (weight)
    """
    path: str
    relevance_score: float
    size_kb: float

    def __post_init__(self):
        """Validate attributes."""
        if not isinstance(self.path, str) or not self.path.strip():
            raise ValueError("path must be a non-empty string")

        if not isinstance(self.relevance_score, (float, int)) or self.relevance_score < 0:
            raise ValueError("relevance_score must be a non-negative number")

        if not isinstance(self.size_kb, (float, int)) or self.size_kb < 0:
            raise ValueError("size_kb must be a non-negative number")

    @property
    def value_density(self) -> float:
        """Calculate value density (relevance per KB)."""
        if self.size_kb == 0:
            return float('inf')
        return self.relevance_score / self.size_kb


@dataclass
class PackResult:
    """
    Result of knapsack packing.

    Attributes:
        selected_files: Files that fit in budget
        total_size_kb: Total size (MUST be <= budget_kb)
        total_value: Sum of relevance scores
        utilization: Percentage of budget used (target: >90%)
        guarantee: Always "HARD" (never exceeds budget)
    """
    selected_files: List[FileCandidate] = field(default_factory=list)
    total_size_kb: float = 0.0
    total_value: float = 0.0
    utilization: float = 0.0
    guarantee: str = "HARD"

    def __post_init__(self):
        """Validate pack result."""
        if self.guarantee != "HARD":
            raise ValueError("guarantee must always be 'HARD'")

        # Validate total_size matches sum of files
        calculated_size = sum(f.size_kb for f in self.selected_files)
        if abs(calculated_size - self.total_size_kb) > 0.01:
            raise ValueError(
                f"total_size_kb mismatch: declared {self.total_size_kb}, "
                f"calculated {calculated_size}"
            )

        # Validate total_value matches sum
        calculated_value = sum(f.relevance_score for f in self.selected_files)
        if abs(calculated_value - self.total_value) > 0.01:
            raise ValueError(
                f"total_value mismatch: declared {self.total_value}, "
                f"calculated {calculated_value}"
            )


class KnapsackPacker:
    """
    Implements 0/1 Knapsack packing with greedy approximation.

    Algorithm (Greedy by Value Density):
    1. Calculate value density (relevance/size) for each file
    2. Sort files by density (descending)
    3. Greedily select files while budget remains
    4. GUARANTEE: sum(selected sizes) <= budget

    This provides HARD guarantee with good approximation
    (typically 90-95% of optimal value).
    """

    def __init__(self):
        """Initialize Knapsack Packer."""
        pass

    def pack(
        self,
        candidates: List[FileCandidate],
        budget_kb: float = 30.0
    ) -> PackResult:
        """
        Pack files into budget using greedy knapsack.

        Args:
            candidates: List of FileCandidate objects
            budget_kb: Hard budget limit in KB (default 30KB)

        Returns:
            PackResult with selected files (GUARANTEED <= budget_kb)

        Example:
            packer = KnapsackPacker()
            candidates = [
                FileCandidate("auth.py", 0.9, 10),
                FileCandidate("test_auth.py", 0.8, 15),
                FileCandidate("utils.py", 0.7, 8)
            ]
            result = packer.pack(candidates, budget_kb=20)

            assert result.total_size_kb <= 20  # HARD GUARANTEE
            print(f"Selected: {[f.path for f in result.selected_files]}")
            print(f"Utilization: {result.utilization:.1%}")
        """
        # Edge cases
        if not candidates:
            return PackResult()

        if budget_kb <= 0:
            return PackResult()

        # Filter valid candidates (size > 0)
        valid_candidates = [
            c for c in candidates
            if c.size_kb > 0 and c.relevance_score >= 0
        ]

        if not valid_candidates:
            return PackResult()

        # Sort by value density (relevance/size) descending
        sorted_candidates = sorted(
            valid_candidates,
            key=lambda c: c.value_density,
            reverse=True
        )

        # Greedy selection
        selected: List[FileCandidate] = []
        current_size = 0.0
        current_value = 0.0

        for candidate in sorted_candidates:
            if current_size + candidate.size_kb <= budget_kb:
                selected.append(candidate)
                current_size += candidate.size_kb
                current_value += candidate.relevance_score

        # Calculate utilization
        utilization = (current_size / budget_kb) if budget_kb > 0 else 0.0

        # Validate budget guarantee
        assert current_size <= budget_kb, (
            f"BUG: Budget violated! {current_size} > {budget_kb}"
        )

        return PackResult(
            selected_files=selected,
            total_size_kb=current_size,
            total_value=current_value,
            utilization=utilization,
            guarantee="HARD"
        )

    def validate_budget(
        self,
        pack_result: PackResult,
        budget_kb: float
    ) -> bool:
        """
        Validate that pack respects budget (assertion check).

        Args:
            pack_result: Pack result to validate
            budget_kb: Budget limit

        Returns:
            True if valid, raises AssertionError otherwise
        """
        total_size = sum(f.size_kb for f in pack_result.selected_files)

        assert total_size <= budget_kb, (
            f"Budget violation: {total_size:.2f} KB > {budget_kb:.2f} KB"
        )

        assert abs(total_size - pack_result.total_size_kb) < 0.01, (
            f"Size mismatch: declared {pack_result.total_size_kb:.2f}, "
            f"actual {total_size:.2f}"
        )

        return True


# Unit tests
if __name__ == "__main__":
    import unittest

    class TestKnapsackPacker(unittest.TestCase):
        def test_empty_candidates(self):
            """Test with empty candidate list."""
            packer = KnapsackPacker()
            result = packer.pack([], budget_kb=30)
            self.assertEqual(len(result.selected_files), 0)
            self.assertEqual(result.total_size_kb, 0.0)

        def test_zero_budget(self):
            """Test with zero budget."""
            packer = KnapsackPacker()
            candidates = [FileCandidate("test.py", 0.9, 10)]
            result = packer.pack(candidates, budget_kb=0)
            self.assertEqual(len(result.selected_files), 0)

        def test_single_file_fits(self):
            """Test single file that fits budget."""
            packer = KnapsackPacker()
            candidates = [FileCandidate("test.py", 0.9, 10)]
            result = packer.pack(candidates, budget_kb=15)

            self.assertEqual(len(result.selected_files), 1)
            self.assertEqual(result.selected_files[0].path, "test.py")
            self.assertLessEqual(result.total_size_kb, 15)

        def test_single_file_exceeds(self):
            """Test single file that exceeds budget."""
            packer = KnapsackPacker()
            candidates = [FileCandidate("huge.py", 0.9, 50)]
            result = packer.pack(candidates, budget_kb=30)

            self.assertEqual(len(result.selected_files), 0)
            self.assertEqual(result.total_size_kb, 0.0)

        def test_all_files_exceed(self):
            """Test when all files exceed budget."""
            packer = KnapsackPacker()
            candidates = [
                FileCandidate("big1.py", 0.9, 40),
                FileCandidate("big2.py", 0.8, 35),
            ]
            result = packer.pack(candidates, budget_kb=30)

            self.assertEqual(len(result.selected_files), 0)

        def test_value_density_selection(self):
            """Test that highest value density files selected first."""
            packer = KnapsackPacker()
            candidates = [
                FileCandidate("low_density.py", 0.5, 10),   # density = 0.05
                FileCandidate("high_density.py", 0.9, 5),   # density = 0.18
                FileCandidate("mid_density.py", 0.6, 8),    # density = 0.075
            ]
            result = packer.pack(candidates, budget_kb=15)

            # Should select high_density first, then mid_density
            selected_paths = [f.path for f in result.selected_files]
            self.assertIn("high_density.py", selected_paths)
            self.assertEqual(result.selected_files[0].path, "high_density.py")

        def test_budget_guarantee(self):
            """Test HARD guarantee: total size never exceeds budget."""
            packer = KnapsackPacker()
            candidates = [
                FileCandidate(f"file{i}.py", max(0.1, 0.9 - i * 0.05), 5 + i)
                for i in range(20)
            ]

            for budget in [10, 20, 30, 50, 100]:
                result = packer.pack(candidates, budget_kb=budget)

                # HARD GUARANTEE
                self.assertLessEqual(result.total_size_kb, budget)
                self.assertEqual(result.guarantee, "HARD")

                # Validate
                self.assertTrue(packer.validate_budget(result, budget))

        def test_high_utilization(self):
            """Test that utilization is generally high (>80%)."""
            packer = KnapsackPacker()
            candidates = [
                FileCandidate(f"file{i}.py", 0.9, 3)
                for i in range(20)
            ]
            result = packer.pack(candidates, budget_kb=30)

            # With many small equal files, should achieve high utilization
            self.assertGreater(result.utilization, 0.80)

        def test_exact_fit(self):
            """Test perfect budget utilization (100%)."""
            packer = KnapsackPacker()
            candidates = [
                FileCandidate("file1.py", 0.9, 10),
                FileCandidate("file2.py", 0.8, 10),
                FileCandidate("file3.py", 0.7, 10),
            ]
            result = packer.pack(candidates, budget_kb=30)

            # Should select all 3 for perfect fit
            self.assertEqual(len(result.selected_files), 3)
            self.assertEqual(result.total_size_kb, 30.0)
            self.assertEqual(result.utilization, 1.0)

        def test_large_number_of_files(self):
            """Test with many files (performance check)."""
            packer = KnapsackPacker()
            candidates = [
                FileCandidate(f"file{i}.py", max(0.1, 0.9 - i * 0.0008), 1 + i * 0.1)
                for i in range(1000)
            ]
            result = packer.pack(candidates, budget_kb=100)

            # Should complete quickly and respect budget
            self.assertLessEqual(result.total_size_kb, 100)
            self.assertGreater(len(result.selected_files), 0)

    # Run tests
    unittest.main()
